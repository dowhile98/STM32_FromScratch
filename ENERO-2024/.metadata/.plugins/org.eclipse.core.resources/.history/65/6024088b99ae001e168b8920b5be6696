/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ----------------------------------------------------------*/
#include <stdint.h>
#include "stm32f4xx.h"
#include <stdio.h>
/*Defines -----------------------------------------------------------*/
/**
 * OFFSET = (0x20C00 + 0x14)-> 0x20C14
 * BWADDR = 0x20C14 * 0x20 + 0xC * 0x4
 * BWADDR = 0x4182B0
 * PD12 = 0x4182B0 + 0X
 */
#define ODR_PD12 *((volatile uint8_t *)(PERIPH_BB_BASE + 0x4182B0))

#define IDR_PA0
/*Global variables --------------------------------------------------*/
uint8_t pa0 = 0;
/*Function prototype ------------------------------------------------*/
int main(void)
{
	/*Init ..........................................................*/
	printf("stm32 - cortex M4\r\n");
	printf("Quino B. Jeffry\r\n");
	printf("%s  %s\r\n", __TIME__, __DATE__);
	/*---------------------------------------------------------------*/
	/**
	 * STM32F4-DISC1
	 * PD12-15 (LED DE USARIO)
	 * PA0 -> BOTTON
	 *
	 * NUCLEO-64 (STM32)
	 * LED1 -> PA5
	 * BOTON -> PC13
	 */
	//1. habilitar el reloj
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIODEN;
	//2. Configurar el modo
	GPIOD->MODER &=~ (GPIO_MODER_MODE12 | GPIO_MODER_MODE13 | GPIO_MODER_MODE14 | GPIO_MODER_MODE15);
	GPIOD->MODER |= 0x1<<(12 * 2); //pd12 como salida de proposito general
	GPIOD->MODER |= GPIO_MODER_MODE13_0 | GPIO_MODER_MODE14_0 | GPIO_MODER_MODE15_0;

	GPIOA->MODER &=~ GPIO_MODER_MODE0;	//INPUT (reset state)
	//3. definir el tipo de salida
	GPIOD->OTYPER &=~ (GPIO_OTYPER_OT12 | GPIO_OTYPER_OT13);					//PUSH PULL

	//4. configurar la velocidad de conmutacion
	GPIOD->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR15; //Vevy high speed
	//5. configurar la resistencia pull up
	GPIOD->PUPDR &=~ (GPIO_PUPDR_PUPD12 | GPIO_PUPDR_PUPD13 | GPIO_PUPDR_PUPD14 | GPIO_PUPDR_PUPD15);

	GPIOA->PUPDR &=~ GPIO_PUPDR_PUPD0;

	/****************************************************************/
	GPIOD->ODR |= GPIO_ODR_OD12;  //SET  1<<12
	GPIOD->ODR &=~ GPIO_ODR_OD12; //RESET (1<<12)

	GPIOD->BSRR |= GPIO_BSRR_BS13; //SET   (1<<13)
	GPIOD->BSRR |= GPIO_BSRR_BR13; //RESET (1<<(16 + 13)

	for(;;){
		pa0 = (GPIOA->IDR >>0) & 0x1;
		if(pa0 == 1){
			//GPIOD->BSRR |= GPIO_BSRR_BS12 | GPIO_BSRR_BR13;
			ODR_PD12 = 1;
		}else{
			//GPIOD->BSRR |= GPIO_BSRR_BR12 | GPIO_BSRR_BS13;
			ODR_PD12 = 0;
		}
	}
}

/*Function definition -----------------------------------------------*/
int __io_putchar(int ch){
	ITM_SendChar(ch);
	//uart
	return ch;
}
