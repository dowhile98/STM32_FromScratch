/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32c0xx.h>
#include <stdbool.h>
//#define RCC_BASE_ADDR	0x40021000
//#define GPIOA_BASE_ADDR	0x40021000
//
//#define RCC_IOPENR_ADDR	(RCC_BASE_ADDR + 0x34)
//
//#define IOPENR		(*(volatile uint32_t*)(RCC_IOPENR_ADDR))

/*Global variables -----------------------------------------------------------*/
#define PA5_ADD			0x40021200
#define PA5				(*(volatile uint8_t *)PA5_ADD) //bit 5 GPIOA->ODR (OD5)
/*Function prototype --------------------------------------------------------*/
void SysTick_Init(uint32_t ticks);
void delay_ms(uint32_t delay);
/*Main function ----------------------------------------------------------------*/

int main(void)
{

	bool PC13;
    /* Loop forever */
//	volatile uint32_t *RCC_IOPENR = (volatile uint32_t *)(RCC_IOPENR_ADDR);
//
//	*RCC_IOPENR |= 1;
//	IOPENR |= 1;
	
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN | RCC_IOPENR_GPIOCEN;
	//LED - PA5
	//SWITCH -> PC13
	//MODER
	GPIOA->MODER &=~ (GPIO_MODER_MODE5); //reset (MODER5)
	GPIOA->MODER |= GPIO_MODER_MODE5_0; 	//Salida de proposito general ;

	GPIOC->MODER &=~ GPIO_MODER_MODE13;		//Reset (MODER13) Entrada
	//OTYPER
	GPIOA->OTYPER &=~ GPIO_OTYPER_OT5;
	//OSPEEDR
	GPIOA->OSPEEDR &=~ GPIO_OSPEEDR_OSPEED5;
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED5_1;//High speed

	//PUPDR
	GPIOA->PUPDR &=~ GPIO_PUPDR_PUPD5;
	GPIOC->PUPDR &=~ GPIO_PUPDR_PUPD13;

	/*Systick init ---------------------------------------*/
	uint32_t ticks = 0;
	/**
	 * LOAD = Freq * T
	 * LOAD =  48MHZ * 100 * 10^(-3)
	 * LOAD = 48MHZ /(10)
	 * LOAD  = 4800 0000
	 */
	SystemCoreClockUpdate();
	ticks = SystemCoreClock / 1000;
	SysTick_Init(ticks);

	
	for(;;){
//		if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk){ //update event
//			GPIOA->ODR ^= 1<<5;
//		}
//		if((millis() - anterior) >= 100){
//			anterior = millis();
//			//todo
//
//		}

		GPIOA->ODR ^= 1<<5;
		delay_ms(10);
	}
}

/*Function definition ----------------------------------------------------*/
void SysTick_Init(uint32_t ticks){
	SysTick->CTRL = 0;
	SysTick->LOAD = ticks - 1;
	SysTick->VAL = 0;

	SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;

	return;
}

void delay_ms(uint32_t delay){
	SysTick->VAL = 0;
	for(uint32_t i = 0; i < delay; i++){
		while(!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk));

	}
}
