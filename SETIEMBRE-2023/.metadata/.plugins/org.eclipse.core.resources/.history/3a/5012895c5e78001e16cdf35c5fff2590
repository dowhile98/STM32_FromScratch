/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ------------------------------------------------*/
#include <stdint.h>
#include "Config.h"
#include "wizchip_conf.h"
#include "delay.h"
#include "dhcp.h"
#include "dns.h"
#include "MQTTClient.h"
#include "mqtt_interface.h"
#include <stdio.h>
#include <string.h>
#include <ArduinoJson.h>
#include <string>
#include "driver_mpu6050.h"
#include "driver_mpu6050_basic.h"
/*Defines -------------------------------------------------*/
#define SPI1_SCK		A, 5
#define SPI1_MOSI		A, 7
#define SPI1_MISO		A, 6
#define SPI1_NSS		B, 1
#define ETH_RST			C, 5

#define ETH_MAX_BUF_SIZE	2048
#define DHCP_SOCKET			0
#define DNS_SOCKET			1
#define MQTT_SOCKET			0
#define DHCP_TIMEOUT		30000



/*Global variables ----------------------------------------*/
wiz_NetInfo gWIZNETINFO = { .mac = {0x00,0x08,0xdc,0x78,0x91,0x71},
							.ip = {192,168,1,120},
							.sn = {255, 255, 255, 0},
							.gw = {192, 168, 1, 1},
							.dns = {168, 126, 63, 1},
							.dhcp = NETINFO_DHCP};
unsigned char ethBuf0[ETH_MAX_BUF_SIZE];
unsigned char ethBuf1[ETH_MAX_BUF_SIZE];
unsigned char ethBuf2[ETH_MAX_BUF_SIZE];
unsigned char ethBuf3[ETH_MAX_BUF_SIZE];

uint8_t URL[] = "broker.hivemq.com";
uint8_t dns_server_ip[4] = {200,48,79,79};
const int mqtt_port = 1883;
uint8_t mqtt_ip[4] = {0};
uint8_t buf[512];
uint8_t pubbuf[512];
uint8_t IP_TYPE;

const uint8_t MQTT_TOPIC[]="Led/control";

typedef struct
{
	char* clientid;
	int nodelimiter;
	char* delimiter;
	enum QoS qos;
	char* username;
	char* password;
	char* host;
	int port;
	int showtopics;
}opts_struct;

opts_struct opts = {
		.clientid = (char*)"STM32-Suscriber",
		.nodelimiter = 0,
		.delimiter =  (char*)"\n",
		.qos = QOS0,
		.username = NULL,
		.password = NULL,
		.host = (char*)mqtt_ip,
		.port = mqtt_port,
		.showtopics = 0
};

unsigned char tempBuffer[1024*2] = {0};
Network n;
MQTTClient c;
//publish topic variables
float T = 0;
bool led = false;
/*Function prototype --------------------------------------*/
void SPI1_Init(void);

uint8_t w5100_ll_read_byte(void);
void w5100_ll_write_byte(uint8_t byte);
void w5100_cs_enable(void);
void w5100_cs_disable(void);
void w5100_reset_assert(void);
void w5100_reset_deassert(void);
void w5100_reset(void);
void w5100_critical_enter(void);
void w5100_critical_exit(void);


void Error_Handler(void);
uint8_t mqtt_publish_data(void);
void print_network_information(void);
int proccess_dhcp(void);
void messageArrived(MessageData* md);
void MQTT_run(void);


/*Main ----------------------------------------------------*/
int main(void)
{
	//systick init
	delay_init_it();
	//spi init
	SPI1_Init();
	//pinout
	RCC->AHB1ENR |= GPIOX_CLOCK(LED) | GPIOX_CLOCK(ETH_RST) | GPIOX_CLOCK(BUTTON);
	GPIOX_MODER(MODE_OUT, ETH_RST);
	GPIOX_MODER(MODE_OUT, LED);
	GPIOX_MODER(MODE_DIGITAL_INPUT, BUTTON);

	//Ethernet W5100
	reg_wizchip_spi_cbfunc(w5100_ll_read_byte, w5100_ll_write_byte);
	reg_wizchip_cs_cbfunc(w5100_cs_enable, w5100_cs_disable);
	reg_wizchip_cris_cbfunc(w5100_critical_enter, w5100_critical_exit);

	//reset
	w5100_reset();
	uint8_t temp = IK_DEST_UNREACH;
	uint8_t W5x00_AdrSet[2][4] = {{2,2,2,2},{2,2,2,2}};

	if(ctlwizchip(CW_INIT_WIZCHIP, (void*)W5x00_AdrSet) == -1){
			Error_Handler();
	}

	if(ctlwizchip(CW_SET_INTRMASK, &temp) == -1){
		Error_Handler();
	}
	wizchip_setnetinfo(&gWIZNETINFO);
	delay_ms(3000);

	//DHCP
	DHCP_init(DHCP_SOCKET, ethBuf0);
	while(1){
		if(proccess_dhcp() == DHCP_IP_LEASED){
		  break;
		}
	}
	//DNS
	DNS_init(DNS_SOCKET, ethBuf1);
	IP_TYPE = 0x1c;
	while(1){
	  if(DNS_run(dns_server_ip, URL, mqtt_ip) == 1){
		  break;
	  }
	}

	//MPU6050 INIT
	mpu6050_b
	//MQTT
	MQTT_run();
    /* Loop forever */
	for(;;);
}


/*Function definition -------------------------------------*/
void SPI1_Init(void){
	//PINOUT
	RCC->AHB1ENR |= GPIOX_CLOCK(SPI1_SCK) | GPIOX_CLOCK(SPI1_MISO) | GPIOX_CLOCK(SPI1_MOSI) |\
			GPIOX_CLOCK(SPI1_NSS);
	GPIOX_MODER(MODE_ALTER, SPI1_SCK);
	GPIOX_AFR(5, SPI1_SCK);

	GPIOX_MODER(MODE_ALTER, SPI1_MISO);
	GPIOX_AFR(5, SPI1_MISO);

	GPIOX_MODER(MODE_ALTER, SPI1_MOSI);
	GPIOX_AFR(5, SPI1_MOSI);

	GPIOX_MODER(MODE_OUT, SPI1_NSS);

	//SPI1
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

	//1. configurar el baudrate
	SPI1->CR1 &=~ SPI_CR1_BR;
	SPI1->CR1 |= SPI_CR1_BR_0;		//Fpclk / 4 = 4MHZ

	//2. Configurar la polaridad y la fase del reloj (SPI MODO 0)
	//CPOL
	SPI1->CR1 &=~ SPI_CR1_CPOL;    //CPOL = 0
	//CPHA
	SPI1->CR1 &=~ SPI_CR1_CPHA;    //CPHA = 0

	//3. configurar la longitud de la trama
	SPI1->CR1 &=~ SPI_CR1_DFF;     //8bits

	//4. configurar el LSP o MSB firts
	SPI1->CR1 &=~ SPI_CR1_LSBFIRST;//MSB first

	//5. Configurar el maneno del pin NSS
	SPI1->CR1 |= SPI_CR1_SSM;       //Software managment
	SPI1->CR1 |= SPI_CR1_SSI;

	//6. configurar el modo TI si fuera necesario

	//7. habilitar el modo maestro
	SPI1->CR1 |= SPI_CR1_MSTR;

	//8. Habilitar el spi
	SPI1->CR1 |= SPI_CR1_SPE;

	return;
}

uint8_t w5100_ll_read_byte(void){
	while(!(SPI1->SR & SPI_SR_TXE));
	*((__IO uint8_t *)&SPI1->DR) = 0xFF;
	while(!(SPI1->SR & SPI_SR_RXNE));
	return (uint8_t)(SPI1->DR);
}
void w5100_ll_write_byte(uint8_t byte){
	uint8_t temp;
	while(!(SPI1->SR & SPI_SR_TXE));
	*((__IO uint8_t *)&SPI1->DR) = byte;
	while(!(SPI1->SR & SPI_SR_RXNE));
	temp = SPI1->DR;

	(void)temp;
	return;
}
void w5100_cs_enable(void){
	GPIOX_ODR(SPI1_NSS) = 0;
	return;
}
void w5100_cs_disable(void){
	GPIOX_ODR(SPI1_NSS) = 1;
}
void w5100_reset_assert(void){
	GPIOX_ODR(ETH_RST) = 0;
}
void w5100_reset_deassert(void){
	GPIOX_ODR(ETH_RST) = 1;
}
void w5100_reset(void){
	GPIOX_ODR(ETH_RST) = 0;
	delay_ms(100);
	GPIOX_ODR(ETH_RST) = 1;
	delay_ms(100);
	return;
}
void w5100_critical_enter(void){
	__disable_irq();
}
void w5100_critical_exit(void){
	__enable_irq();
}

void Error_Handler(void){
	printf("error\r\n");
	__disable_irq();
	while(1){

	}
}

uint8_t mqtt_publish_data(void){
	std::string buff;
	StaticJsonDocument<256> doc;
	MQTTMessage m;
	int rc = 0;
	//message init
	m.qos = QOS0;
	m.retained = 0;
	m.dup = 0;
	//message json
	doc["id"] = "STM32F407VG";
	doc["led"] = led;
	doc["temperature"] = T;

	serializeJson(doc, buff);
	//publish data
	m.payload = (void *)buff.c_str();
	m.payloadlen = buff.length();
	rc = MQTTPublish(&c, (const char*)"Led/estado", &m);
	if(rc == SUCCESSS){
		printf("Published %d\r\n", rc);
	}else{
		printf("Published error! %d\r\n", rc);
	}
	return rc;

}

void print_network_information(void)
{
	memset(&gWIZNETINFO,0,sizeof(gWIZNETINFO));

	wizchip_getnetinfo(&gWIZNETINFO);
	printf("MAC Address : %02x:%02x:%02x:%02x:%02x:%02x\n\r",gWIZNETINFO.mac[0],gWIZNETINFO.mac[1],gWIZNETINFO.mac[2],gWIZNETINFO.mac[3],gWIZNETINFO.mac[4],gWIZNETINFO.mac[5]);
	printf("IP  Address : %d.%d.%d.%d\n\r",gWIZNETINFO.ip[0],gWIZNETINFO.ip[1],gWIZNETINFO.ip[2],gWIZNETINFO.ip[3]);
	printf("Subnet Mask : %d.%d.%d.%d\n\r",gWIZNETINFO.sn[0],gWIZNETINFO.sn[1],gWIZNETINFO.sn[2],gWIZNETINFO.sn[3]);
	printf("Gateway     : %d.%d.%d.%d\n\r",gWIZNETINFO.gw[0],gWIZNETINFO.gw[1],gWIZNETINFO.gw[2],gWIZNETINFO.gw[3]);
	printf("DNS Server  : %d.%d.%d.%d\n\r",gWIZNETINFO.dns[0],gWIZNETINFO.dns[1],gWIZNETINFO.dns[2],gWIZNETINFO.dns[3]);
}

int proccess_dhcp(void){
	int8_t ret = 0;
	uint32_t timout = millis();
	while(1){
		ret = DHCP_run();

		if(ret == DHCP_IP_LEASED){
			//printf information
			memset(&gWIZNETINFO,0,sizeof(gWIZNETINFO));

			wizchip_getnetinfo(&gWIZNETINFO);
			print_network_information();
			break;
		}

		else if(ret == DHCP_FAILED){
			//todo

		}

		//check timeout
		if((millis() - timout) >= DHCP_TIMEOUT ){
			DHCP_stop();
			break;
		}

	}
	return ret;
}

void messageArrived(MessageData* md)
{
	StaticJsonDocument<256> doc;
	DeserializationError err;
	unsigned char topicSusc[100];
	uint32_t rd_size;
	uint32_t rd_pt;
	uint32_t rdmore_size;

	MQTTMessage* message = md->message;
	MQTTString* topic = md->topicName;

	rdmore_size = (int)topic->lenstring.len;
	rd_pt = 0;

	while(rdmore_size != 0)
	{
		if(rdmore_size > sizeof(topicSusc) - 1)
		{
			rd_size = sizeof(topicSusc) - 1;
		}
		else
		{
			rd_size = rdmore_size;
		}

		memset(topicSusc, 0, rd_size + 1);

		memcpy(topicSusc, ((char*)topic->lenstring.data) + rd_pt, rd_size);
		printf("SubScribe Topic : %s\r\n", topicSusc);
		rd_pt += rd_size;
		rdmore_size -= rd_size;
	}

	if (opts.nodelimiter)
	{
		printf("Message 1 : %.*s\r\n", (int)message->payloadlen, (char*)message->payload);
	}
	else
	{
		printf("Message 2: %.*s%s\r\n", (int)message->payloadlen, (char*)message->payload, opts.delimiter);
	}
	//Procesar el json
	std::string msg((char*)message->payload, (int)message->payloadlen);
	err = deserializeJson(doc, msg);
	if(err){
		printf("error deserialize json\r\n");
	}else{
		//process json
		if(doc["ledState"] == true){
			GPIOX_ODR(LED) = 1;
			led = true;
		}else{
			GPIOX_ODR(LED) = 0;
			led = false;
		}
		mqtt_publish_data();
	}
	return;
}

void MQTT_run(void){
	int rc = 0;


	uint32_t ck_timer;

	NewNetwork(&n, MQTT_SOCKET);
	ConnectNetwork(&n, mqtt_ip, mqtt_port);
	MQTTClientInit(&c, &n, 1000, buf, sizeof(buf), tempBuffer, sizeof(tempBuffer));

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;
	data.willFlag = 0;
	data.MQTTVersion = 3;
	data.clientID.cstring = opts.clientid;
	data.username.cstring = opts.username;
	data.password.cstring = opts.password;
	data.keepAliveInterval = 60;
	data.cleansession = 1;

	if(MQTTConnect(&c, &data) == SUCCESSS){
		printf("connect server\r\n");
	}else{
		printf("disconnect\r\n");
		Error_Handler();
	}
	opts.showtopics = 1;

	printf("Subscribing to %s\r\n", MQTT_TOPIC);
	rc = MQTTSubscribe(&c, ( const char*)MQTT_TOPIC, opts.qos, messageArrived);
	printf("Subscribed %d\r\n", rc);



	ck_timer = millis();

	while(1){
		MQTTYield(&c, data.keepAliveInterval);

		//publish data

		if((millis() - ck_timer) >= 10000){
			ck_timer = millis();
			T += 2.3;
			if(T > 30){
				T = 4;
			}

			mqtt_publish_data();
		}
	}
}



/*Isr ------------------------------------------.*/

