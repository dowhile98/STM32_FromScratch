/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32c0xx.h>
#include <stdbool.h>
#include <delay.h>
#include <lwbtn/lwbtn.h>
#include <stdio.h>
/*Typedef ---------------------------------------*/
typedef uint8_t (*readFc)(void);

/*Global variables ------------------------------*/
uint32_t ledTicks = 0;
uint32_t buttonTicks = 0;



uint8_t getButton1(void){
	return (GPIOC->IDR) ? 0: 1;
}
uint8_t getButton2(void){
	return (GPIOC->IDR) ? 0: 1;
}
uint8_t getButton3(void){
	return (GPIOC->IDR) ? 0: 1;
}

typedef enum{
	BUTTON1 = 0,
	BUTTON2,
	BUTTON3

}Btns_enum_t;

uint8_t pins[] = {BUTTON1, BUTTON2, BUTTON3};

static lwbtn_btn_t btns[] = {
		{.arg = (void *)getButton1},
		{.arg = (void *)getButton2},
		{.arg = (void *)getButton3}
};


/*Function prototype ---------------------------*/
void
prv_btn_event(struct lwbtn* lw, struct lwbtn_btn* btn, lwbtn_evt_t evt);
uint8_t
prv_btn_get_state(struct lwbtn* lw, struct lwbtn_btn* btn);


void  TIM14_BaseInit(uint16_t freq);
/*Main function ----------------------------------*/
int main(void)
{
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN | RCC_IOPENR_GPIOCEN;
	//LED - PA5
	//SWITCH -> PC13
	//MODER
	GPIOA->MODER &=~ (GPIO_MODER_MODE5); //reset (MODER5)
	GPIOA->MODER |= GPIO_MODER_MODE5_0; 	//Salida de proposito general ;

	GPIOC->MODER &=~ GPIO_MODER_MODE13;		//Reset (MODER13) Entrada
	//OTYPER
	GPIOA->OTYPER &=~ GPIO_OTYPER_OT5;
	//OSPEEDR
	GPIOA->OSPEEDR &=~ GPIO_OSPEEDR_OSPEED5;
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED5_1;//High speed

	//PUPDR
	GPIOA->PUPDR &=~ GPIO_PUPDR_PUPD5;
	GPIOC->PUPDR &=~ GPIO_PUPDR_PUPD13;

	//poner en alto el pin
	GPIOA->ODR |= GPIO_ODR_OD5;
//	GPIOA->BSRR |= GPIO_BSRR_BS5; //1<<5
	//poner en bajo el pin
	GPIOA->ODR &=~ GPIO_ODR_OD5;
//	GPIOA->BSRR |= GPIO_BSRR_BR5; //1<<21
	SystemCoreClockUpdate();
	delay_init(SystemCoreClock / 1000);

	ledTicks = GetTicks();
	buttonTicks = GetTicks();
	//button init

	lwbtn_init(btns, 3,prv_btn_get_state, prv_btn_event);

	/*timter init*/
	TIM14_BaseInit(50);
	for(;;){
//		if((GetTicks() - ledTicks) >= 10){
//			ledTicks = GetTicks();
//			GPIOA->ODR ^= 1<<5;
//		}
		if((GetTicks() - buttonTicks)>= 5){
			//todo
			buttonTicks = GetTicks();
			lwbtn_process(GetTicks());
		}
	}
}


/*Function definition ---------------------------------------------*/
uint8_t
prv_btn_get_state(struct lwbtn* lw, struct lwbtn_btn* btn){


	readFc fc = (readFc)btn->arg;
	return fc();
//	switch(buttons){
//	case BUTTON1:
//		if(GPIOC->IDR & GPIO_IDR_ID13){
//			return 0;
//		}else{
//			return 1;
//		}
//
//		break;
//	case BUTTON2:
//		return(GPIOC->IDR & GPIO_IDR_ID8) ? 1: 0;
//		break;
//	case BUTTON3:
//		//todo
//
//		break;
//	}
	return 0;
}

/**
 * \brief           Button event
 *
 * \param           lw: LwBTN instance
 * \param           btn: Button instance
 * \param           evt: Button event
 */
void
prv_btn_event(struct lwbtn* lw, struct lwbtn_btn* btn, lwbtn_evt_t evt){
	readFc button = (readFc)btn->arg;
	uint8_t event = evt;

	switch(event){
	case LWBTN_EVT_ONPRESS:
		if(button == getButton1){
			printf("BUTTON 1 ON PRESS\r\n");
		}
		break;
	case LWBTN_EVT_ONRELEASE:
		if(button == getButton1){
			printf("BUTTON 1 ON RELEASE\r\n");
		}
		break;
	case LWBTN_EVT_ONCLICK:
		if(button == getButton1){
			printf("BUTTON 1 ON CLICK:%d\r\n", btn->click.cnt);
		}
		break;
	case LWBTN_EVT_KEEPALIVE:
		if(button == getButton1){
			GPIOA->ODR ^= 1<<5;
		}
		break;
	}
}


void  TIM14_BaseInit(uint16_t freq){
	uint16_t temp = 0;
	/*habilitar el reloj*/
	RCC->APBENR2 |= RCC_APBENR2_TIM14EN;
	/*COnfiguracion del timer*/
	TIM14->CR1 = 0;
	/**
	 * ARR = (PCS_CK / (PSC + 1)(freq) - 1
	 * ARR = (48MHZ /(799 + 1)(1) - 1
	 * ARR = 60000 - 1
	 *
	 * ARR = 48MHZ /(799 + 1)(1000)
	 * ARR = 60 - 1
	 */
	TIM14->PSC = 800 - 1;
	temp = (48E+6) /(( 800) * (freq)) - 1;
	TIM14->ARR = temp;

	TIM14->CNT = 0;

	/*interruptcion*/
	TIM14->DIER |= TIM_DIER_UIE;
	NVIC_EnableIRQ(TIM14_IRQn);		//Habilita la interrupcion
	NVIC_SetPriority(TIM14_IRQn, 5);//cambiar la prioridad de la IT

	/*Habilitar el timer*/
	TIM14->CR1 |= TIM_CR1_CEN;
	return;
}
