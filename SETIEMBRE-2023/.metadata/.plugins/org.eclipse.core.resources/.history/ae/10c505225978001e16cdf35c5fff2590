/*
 * i2c.c
 *
 *  Created on: Oct 31, 2023
 *      Author: jeffr
 */
#include "i2c.h"

void I2C1_Init(void){
	uint32_t temp;
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SDA);
	GPIOB->OTYPER |= GPIO_OTYPER_OT7 | GPIO_OTYPER_OT6;
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SCL);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SDA);//VERY HIGH SPEED
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SDA);		//Habilita las resitencias pull up internas
	GPIOX_AFR(4, I2C1_SCL);
	GPIOX_AFR(4, I2C1_SDA);
	//CONFIGURAR EL I2C1
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	//RESET
	I2C1->CR1 |= I2C_CR1_SWRST;
	I2C1->CR1 &=~ I2C_CR1_SWRST;
	/**
	 * PCLK1
	 */
	temp = SystemCoreClock / 1000000;
	I2C1->CR2 &=~ (I2C_CR2_FREQ);
	I2C1->CR2 |= (temp & 0x3F);
	/**
	 * TIMING (CCR)
	 * ->STANDART MODE = 100KHz
	 * CCR = PCLK1 / (2 * 100000)
	 * ->FAST MODE = 400KHz
	 * DUTY CYCLE (DUTY->CCR)
	 * DUTY == 0
	 * CCR = PCLK1 / (3 * 400000)
	 * DUTY == 1
	 * CCR = PCLK1 / (25 * 400000)
	 * ->FAST MODE PLUS
	 */
	temp = 16E+6 / (3 * 400E+3);
	I2C1->CCR = temp & 0xFFF;
	I2C1->CCR |= I2C_CCR_FS;
	/*Configurar el TRISE*/
	/**
	 * SM
	 * TRISE = PCLK1 / 1000000 + 1
	 * FS
	 * TRISE = (PCLK1 * 300) / (1000000000U) + 1
	 */
	temp = ((16E+6) * 300) / (1000000000U) + 1;
	I2C1->TRISE = temp;
	//DIRECCION ESCLAVA DE NUESTRO I2C1
	I2C1->OAR1 = 0x74;
	//habilitar el bus i2c
	I2C1->CR1 |= I2C_CR1_PE;
	return;
}
