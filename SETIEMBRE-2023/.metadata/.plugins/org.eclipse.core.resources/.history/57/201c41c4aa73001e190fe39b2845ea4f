/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ------------------------------------------------*/
#include <stdint.h>
#include "Config.h"
#include "wizchip_conf.h"
#include "delay.h"
/*Defines -------------------------------------------------*/
#define SPI1_SCK		A, 5
#define SPI1_MOSI		A, 7
#define SPI1_MISO		A, 6
#define SPI1_NSS		B, 6
#define ETH_RST			C, 7

#define DHCP_SOCKET			0
#define DNS_SOCKET			1
#define MQTT_SOCKET			0

/*Global variables ----------------------------------------*/
wiz_NetInfo gWIZNETINFO = { .mac = {0x00,0x08,0xdc,0x78,0x91,0x71},
							.ip = {192,168,1,90},
							.sn = {255, 255, 255, 0},
							.gw = {192, 168, 1, 1},
							.dns = {168, 126, 63, 1},
							.dhcp = NETINFO_DHCP};
/*Function prototype --------------------------------------*/
void SPI1_Init(void);

uint8_t w5100_ll_read_byte(void);
void w5100_ll_write_byte(uint8_t byte);
void w5100_cs_enable(void);
void w5100_cs_disable(void);
void w5100_reset_assert(void);
void w5100_reset_deassert(void);
void w5100_reset(void);
void w5100_critical_enter(void);
void w5100_critical_exit(void);

void Error_Handler(void){
	printf("error\r\n");
	__disable_irq();
	while(1){

	}
}
/*Main ----------------------------------------------------*/
int main(void)
{
	//systick init
	delay_init_it();
	//spi init
	SPI1_Init();
	//pinout
	RCC->AHB1ENR |= GPIOX_CLOCK(LED) | GPIOX_CLOCK(ETH_RST) | GPIOX_CLOCK(BUTTON);
	GPIOX_MODER(MODE_OUT, ETH_RST);
	GPIOX_MODER(MODE_OUT, LED);
	GPIOX_MODER(MODE_DIGITAL_INPUT, BUTTON);

	//Ethernet W5100
	reg_wizchip_spi_cbfunc(w5100_ll_read_byte, w5100_ll_write_byte);
	reg_wizchip_cs_cbfunc(w5100_cs_enable, w5100_cs_disable);
	reg_wizchip_cris_cbfunc(w5100_critical_enter, w5100_critical_exit);

	//reset
	w5100_reset();
	uint8_t temp = IK_DEST_UNREACH;
	uint8_t W5x00_AdrSet[2][4] = {{2,2,2,2},{2,2,2,2}};

	if(ctlwizchip(CW_INIT_WIZCHIP, (void*)W5x00_AdrSet) == -1){
			Error_Handler();
	}

	if(ctlwizchip(CW_SET_INTRMASK, &temp) == -1){
		Error_Handler();
	}
	wizchip_setnetinfo(&gWIZNETINFO);
	delay_ms(3000);

	//
    /* Loop forever */
	for(;;);
}


/*Function definition -------------------------------------*/
void SPI1_Init(void){
	//PINOUT
	RCC->AHB1ENR |= GPIOX_CLOCK(SPI1_SCK) | GPIOX_CLOCK(SPI1_MISO) | GPIOX_CLOCK(SPI1_MOSI) |\
			GPIOX_CLOCK(SPI1_NSS);
	GPIOX_MODER(MODE_ALTER, SPI1_SCK);
	GPIOX_AFR(5, SPI1_SCK);

	GPIOX_MODER(MODE_ALTER, SPI1_MISO);
	GPIOX_AFR(5, SPI1_MISO);

	GPIOX_MODER(MODE_ALTER, SPI1_MOSI);
	GPIOX_AFR(5, SPI1_MOSI);

	GPIOX_MODER(MODE_OUT, SPI1_NSS);

	//SPI1
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

	//1. configurar el baudrate
	SPI1->CR1 &=~ SPI_CR1_BR;
	SPI1->CR1 |= SPI_CR1_BR_0;		//Fpclk / 4 = 4MHZ

	//2. Configurar la polaridad y la fase del reloj (SPI MODO 0)
	//CPOL
	SPI1->CR1 &=~ SPI_CR1_CPOL;    //CPOL = 0
	//CPHA
	SPI1->CR1 &=~ SPI_CR1_CPHA;    //CPHA = 0

	//3. configurar la longitud de la trama
	SPI1->CR1 &=~ SPI_CR1_DFF;     //8bits

	//4. configurar el LSP o MSB firts
	SPI1->CR1 &=~ SPI_CR1_LSBFIRST;//MSB first

	//5. Configurar el maneno del pin NSS
	SPI1->CR1 |= SPI_CR1_SSM;       //Software managment
	SPI1->CR1 |= SPI_CR1_SSI;

	//6. configurar el modo TI si fuera necesario

	//7. habilitar el modo maestro
	SPI1->CR1 |= SPI_CR1_MSTR;

	//8. Habilitar el spi
	SPI1->CR1 |= SPI_CR1_SPE;

	return;
}

uint8_t w5100_ll_read_byte(void){
	while(!(SPI1->SR & SPI_SR_TXE));
	*((__IO uint8_t *)&SPI1->DR) = 0xFF;
	while(!(SPI1->SR & SPI_SR_RXNE));
	return (uint8_t)(SPI1->DR);
}
void w5100_ll_write_byte(uint8_t byte){
	uint8_t temp;
	while(!(SPI1->SR & SPI_SR_TXE));
	*((__IO uint8_t *)&SPI1->DR) = byte;
	while(!(SPI1->SR & SPI_SR_RXNE));
	temp = SPI1->DR;

	(void)temp;
	return;
}
void w5100_cs_enable(void){
	GPIOX_ODR(SPI1_NSS) = 0;
	return;
}
void w5100_cs_disable(void){
	GPIOX_ODR(SPI1_NSS) = 1;
}
void w5100_reset_assert(void){
	GPIOX_ODR(ETH_RST) = 0;
}
void w5100_reset_deassert(void){
	GPIOX_ODR(ETH_RST) = 1;
}
void w5100_reset(void){
	GPIOX_ODR(ETH_RST) = 0;
	delay_ms(100);
	GPIOX_ODR(ETH_RST) = 1;
	delay_ms(100);
	return;
}
void w5100_critical_enter(void){
	__disable_irq();
}
void w5100_critical_exit(void){
	__enable_irq();
}


/*Isr ------------------------------------------.*/
void SysTick_Handler(void){
	if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk){
			uwTick += 1;
	}
}
