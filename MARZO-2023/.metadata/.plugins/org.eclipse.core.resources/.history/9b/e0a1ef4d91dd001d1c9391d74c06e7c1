/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes -------------------------------------------------------------------*/
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "defines.h"
#include "delay.h"
#include <stdbool.h>
#include <driver_mpu6050.h>
#include <driver_mpu6050_basic.h>
/*Typedef --------------------------------------------------------------------*/


/*Defines ------------------------------------------------------------------- */
#define I2C1_SCL		B, 6
#define I2C1_SDA 		B, 7
#define MPU6050_IT		A, 6
/*Global variables ---------------------------------------------------------- */
uint32_t read = 0;
/*function prototype ---------------------------------------------------------*/
/**
  * @fn configura los pines necesarios
	*/
void GPIO_Config(void);

void I2C1_Init(void);
/**
 * @brief funcion para el envio de datos por I2C
 * @param [I2Cx] 		instancia al i2c usado (I2C1, I2C2 ...)
 * @param [slaveAddr] 	direccion del esclavo
 * @param [pData] 		puntero al buffer a enviar
 * @param [Len] 		cantidad de datos a enviar
 * @param [timeout] 	tiempo maximo de espera para el envio de datos
 */
bool I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout);

/**
 * @brief funcion para la recepcion de datos por I2C
 * @param [I2Cx] 		instancia al i2c usado (I2C1, I2C2 ...)
 * @param [slaveAddr] 	direccion del esclavo
 * @param [pData] 		puntero al buffer donde se va recibir los datos
 * @param [Len] 		cantidad de datos a recibir
 * @param [timeout] 	tiempo maximo de espera para la recepcion de datos de datos
 */
bool I2C_MasterReceiveData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout);

bool i2c_write_reg(I2C_TypeDef *I2Cx, uint8_t slaveAddr,uint8_t reg_addr, uint8_t *pData, uint32_t Len, uint32_t timeout);

bool i2c_read_reg(I2C_TypeDef *I2Cx, uint8_t slaveAddr,uint8_t reg_addr, uint8_t *pData, uint32_t Len, uint32_t timeout);

bool I2C_isDeviceConnected(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint32_t timeout);

/*main function --------------------------------------------------------------*/

int main(void)
{
	/*Local variables ----------------------------*/

	/*Peripheral init ----------------------------*/
	SysTickInit();
	I2C1_Init();
	GPIO_Config();
	/*Sensor init --------------------------------*/
	mpu6050_basic_init(0x68);
	float a[3];
	float g[3];
	float temp;
    /* Loop forever */
	for(;;){


		delay_ms(10);
	}
}

/*Function definition ---------------------------------------------------------*/
void I2C1_Init(void){
	uint32_t temp;
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SDA);
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SCL);		//Habilita el modo open drain
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SDA);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SCL);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SDA);//VERY HIGH SPEED
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SDA);		//Habilita las resitencias pull up internas
	GPIOX_AFR(4, I2C1_SCL);
	GPIOX_AFR(4, I2C1_SDA);
	/*I2C1 -------------------------------------------------*/
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	//RESET
	I2C1->CR1 |= I2C_CR1_SWRST;
	I2C1->CR1 &=~ I2C_CR1_SWRST;
	/**
	 * PCLK1 -> FREQ = 16MHz
	 */
	temp = SystemCoreClock / 1E+6;
	I2C1->CR2 = temp & 0x3F;
	/**
	 * TIMING (CCR)
	 * ->STANDART MODE = 100KHz
	 * CCR = PCLK1 / (2 * 100000)
	 * ->FAST MODE = 400KHz
	 * DUTY CYCLE (DUTY->CCR)
	 * DUTY == 0
	 * CCR = PCLK1 / (3 * 400000)
	 * DUTY == 1
	 * CCR = PCLK1 / (25 * 400000)
	 * ->FAST MODE PLUS
	 */
	temp = 16E+6 / (3 * 400E+3);
	temp = 13;
	I2C1->CCR = temp & 0xFFF;
	//I2C1->CCR |= I2C_CCR_DUTY;
	/*Configurar el TRISE*/
	/**
	 * SM
	 * TRISE = PCLK1 / 1000000 + 1
	 * FS
	 * TRISE = (PCLK1 * 300) / (1000000000U) + 1
	 */
	temp = ((16E+6) * 300) / (1000000000U) + 1;
	I2C1->TRISE = temp;
	/*configurar la direccion esclava*/
	I2C1->OAR1 = 0x73;
	/*habilitar el I2C1*/
	I2C1->CR1 |= I2C_CR1_PE;
}
bool I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout){
	volatile uint32_t temp;

	uint32_t tickstart = GetTicks();
	uint8_t stateuml = 0;
	//verificas el estado de los datos a transmitir
	if(Len <= 0 || pData == ((void *)0)){
		return false;
	}

	/*esperar la linea se libere*/
	while((GetTicks() - tickstart)<timeout){
		switch(stateuml){
		case 0: //esperar que la linea se libere
			if(!(I2Cx->SR2 & I2C_SR2_BUSY)){
				stateuml = 1;
			}
			break;
		case 1: //generar la condicion de inicio
			I2Cx->CR1 |= I2C_CR1_START;
			stateuml = 2;
		case 2: //esperar la respuesta al start
			if(I2Cx->SR1 & I2C_SR1_SB){
				stateuml = 3;
			}
			break;
		case 3: //enviar la direccion del esclavo
			slaveAddr = slaveAddr<<1;
			slaveAddr &=~ (1U);			//write
			I2Cx->DR = slaveAddr;
			stateuml = 4;
			break;
		case 4:	//esperar la respuesta del esclavo
			if(I2Cx->SR1 & I2C_SR1_ADDR){
				//limpiar los registros de estado
				temp = I2Cx->SR1;
				temp = I2Cx->SR2;
				(void)temp;
				stateuml = 5;
			}
			break;
		case 5: //enviar los datos
			if(Len>0){
				if(I2Cx->SR1 & I2C_SR1_TXE){
					I2Cx->DR = *pData;
					pData++;
					Len--;
				}
			}else{
				stateuml  = 6;
			}
			break;
		case 6: //esperar que se transmitan los datos y generar la condicion de parada
			while(!(I2Cx->SR1 & I2C_SR1_TXE));
			while(!(I2Cx->SR1 & I2C_SR1_BTF));
			I2Cx->CR1 |= I2C_CR1_STOP;
			return true;
		}
	}
	I2Cx->CR1 |= I2C_CR1_STOP;
	return false;
}
bool I2C_isDeviceConnected(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint32_t timeout){
	volatile uint32_t temp;

	uint32_t tickstart = GetTicks();
	uint8_t stateuml = 0;

	/*esperar la linea se libere*/
	while((GetTicks() - tickstart)<timeout){
		switch(stateuml){
		case 0: //esperar que la linea se libere
			if(!(I2Cx->SR2 & I2C_SR2_BUSY)){
				stateuml = 1;
			}
			break;
		case 1: //generar la condicion de inicio
			I2Cx->CR1 |= I2C_CR1_START;
			stateuml = 2;
		case 2: //esperar la respuesta al start
			if(I2Cx->SR1 & I2C_SR1_SB){
				stateuml = 3;
			}
			break;
		case 3: //enviar la direccion del esclavo
			slaveAddr = slaveAddr<<1;
			slaveAddr &=~ (1U);			//write
			I2Cx->DR = slaveAddr;
			stateuml = 4;
			break;
		case 4:	//esperar la respuesta del esclavo
			if(I2Cx->SR1 & I2C_SR1_ADDR){
				//limpiar los registros de estado
				temp = I2Cx->SR1;
				temp = I2Cx->SR2;
				(void)temp;
				I2Cx->CR1 |= I2C_CR1_STOP;
				return true;
			}
		}
	}
	I2Cx->CR1 |= I2C_CR1_STOP;
	return false;
}
bool I2C_MasterReceiveData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout){
	volatile uint32_t temp;
	uint32_t tickstart = GetTicks();
	uint8_t stateuml = 0;
	//verificas el estado de los datos a transmitir
	if(Len <= 0 || pData == ((void *)0)){
		return false;
	}

	while((GetTicks() - tickstart)<timeout){
		switch(stateuml){
		case 0: //esperar que la linea se libere
			if(!(I2Cx->SR2 & I2C_SR2_BUSY)){
				stateuml = 1;
			}
			break;
		case 1: //generar la condicion de inicio
			I2Cx->CR1 |= I2C_CR1_START;
			stateuml = 2;
		case 2: //esperar la respuesta del start
			if(I2Cx->SR1 & I2C_SR1_SB){
				stateuml = 3;
			}
			break;
		case 3:  //enviar la direccion del esclavo
			slaveAddr = slaveAddr<<1;
			slaveAddr |= (1U);			//read
			I2Cx->DR = slaveAddr;
			stateuml = 4;
			break;
		case 4:	//esperar la respuesta del esclavo
			if(I2Cx->SR1 & I2C_SR1_ADDR){
				//limpiar los registros de estado
				temp = I2Cx->SR1;
				temp = I2Cx->SR2;
				(void)temp;
				/*habilitar el acknowlegde signal*/
				I2Cx->CR1 |= I2C_CR1_ACK;
				stateuml = 5;
			}
			break;
		case 5: //recibir los datos
			if(Len>1){
				//esperar el bit RXNE se ponga 1
				if(I2Cx->SR1 & I2C_SR1_RXNE){
					*pData = I2Cx->DR;
					pData++;
					Len--;
				}
			}else{
				/*deshabilitar el bit ACK*/
				I2Cx->CR1 &=~ I2C_CR1_ACK;
				/*esperamos el dato*/
				if(I2Cx->SR1 & I2C_SR1_RXNE){
					//generar la condicion de parada
					I2Cx->CR1 |= I2C_CR1_STOP;
					//lee el dato
					*pData = I2Cx->DR;
					Len--;
					return true;
				}
			}
			break;
		}
	}
	I2Cx->CR1 |= I2C_CR1_STOP;

	return false;
}

bool i2c_write_reg(I2C_TypeDef *I2Cx, uint8_t slaveAddr,uint8_t reg_addr, uint8_t *pData, uint32_t Len, uint32_t timeout){
	bool state = I2C_MasterSendData(I2Cx, slaveAddr, &reg_addr, 1, timeout);
	if(state == true){
		state = I2C_MasterSendData(I2Cx, slaveAddr, pData, Len, timeout);
	}
	return state;
}

bool i2c_read_reg(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t reg_addr, uint8_t *pData, uint32_t Len, uint32_t timeout){

	if(I2C_MasterSendData(I2Cx, slaveAddr, &reg_addr, 1, timeout) == true){
		return I2C_MasterReceiveData(I2Cx, slaveAddr, pData, Len, timeout);
	}
	return false;
}

/**
  * @fn configura los pines necesarios
	*/
void GPIO_Config(void){

	/*PA6 -> EXTI */
	RCC->AHB1ENR |= GPIOX_CLOCK(MPU6050_IT);
	GPIOX_MODER(MODE_DIGITAL_INPUT, MPU6050_IT);

	GPIOX_PUPDR(MODE_PU_NONE, MPU6050_IT);

	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

	EXTI->IMR |= EXTI_IMR_IM6;
	EXTI->RTSR |= EXTI_RTSR_TR6;
	EXTI->PR |= EXTI_PR_PR6;

	SYSCFG->EXTICR[1] &=~ SYSCFG_EXTICR2_EXTI6;
	SYSCFG->EXTICR[1] |= SYSCFG_EXTICR2_EXTI6_PA;

	NVIC_EnableIRQ(EXTI9_5_IRQn);

	return;
}

void EXTI9_5_IRQHandler(void){
	if(EXTI->PR & EXTI_PR_PR6){
		EXTI->PR |= EXTI_PR_PR6;
		/*CODE HERE*/
		read = 1;

	}
}


int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
