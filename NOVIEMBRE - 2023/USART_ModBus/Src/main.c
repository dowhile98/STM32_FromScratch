/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "delay.h"
#include <stdio.h>
#include <string.h>
#include "main.h"
#include "nanomodbus.h"
/*Defines --------------------------------------------------------------------*/

/*Typedefs -------------------------------------------------------------------*/

/*Global variables -----------------------------------------------------------*/


/*Function prototype ---------------------------------------------------------*/
void USART1_Config(void);
int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}


uint8_t uart_send_data(USART_TypeDef *USART, uint8_t *pData, uint32_t len, uint32_t timeout);
int32_t read_serial(uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg);
int32_t write_serial(const uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg); 
void onError();
/*Main function --------------------------------------------------------------*/
int main(void)
{
	nmbs_platform_conf platform_conf;
	platform_conf.transport = NMBS_TRANSPORT_RTU;
  	platform_conf.read = read_serial;
  	platform_conf.write = write_serial;
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOGEN;
	GPIOG->MODER &=~ (GPIO_MODER_MODE13);
	GPIOG->MODER |= GPIO_MODER_MODE13_0;

	SysTick_Config(16000);
	USART1_Config();
	//habilitar la interrupcion para la recepcion
	printf("USART1 Init OK!\r\n");

	nmbs_t nmbs;
	nmbs_error err = nmbs_client_create(&nmbs, &platform_conf);
	if (err != NMBS_ERROR_NONE)
		onError();
	nmbs_set_read_timeout(&nmbs, 1000);
  	nmbs_set_byte_timeout(&nmbs, 100);

  	nmbs_set_destination_rtu_address(&nmbs, 0x1);
	for(;;){
		nmbs_bitfield coils = {0};
		nmbs_bitfield_write(coils, 0, 1);
		nmbs_bitfield_write(coils, 1, 1);
		err = nmbs_write_multiple_coils(&nmbs, 64, 2, coils);
		// if (err != NMBS_ERROR_NONE)
		// 	onError();

		// Read 3 coils from address 64
		nmbs_bitfield_reset(coils);    // Reset whole bitfield to zero
		err = nmbs_read_coils(&nmbs, 64, 3, coils);
		// if (err != NMBS_ERROR_NONE)
		// 	onError();

		// Write 2 holding registers at address 26
		uint16_t w_regs[6] = {123, 124, 1, 2, 3, 4};
		err = nmbs_write_multiple_registers(&nmbs, 26, 6, w_regs);
		// if (err != NMBS_ERROR_NONE)
		// 	onError();

		// Read 2 holding registers from address 26
		uint16_t r_regs[2];
		err = nmbs_read_holding_registers(&nmbs, 26, 2, r_regs);
		// if (err != NMBS_ERROR_NONE)
		// 	onError();
		/* Loop forever */
		delay_ms(5000);
	}
}
/*Function definition --------------------------------------------------------*/
void USART1_Config(void){
	//1. configurar los pines
	//PA9 y PA10
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER &=~ (GPIO_MODER_MODE9 | GPIO_MODER_MODE10);
	GPIOA->MODER |= GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1; //FA

	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED9 | GPIO_OSPEEDR_OSPEED10;  //Very high speed
	//Asignacion de funcion alternativa
	GPIOA->AFR[1] &=~(GPIO_AFRH_AFSEL9 | GPIO_AFRH_AFSEL10);
	GPIOA->AFR[1] |= 0x7<<GPIO_AFRH_AFSEL9_Pos | 0x7<<GPIO_AFRH_AFSEL10_Pos;
	//2. habilitar el reloj
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
	//3. Deshabilitar
	USART1->CR1 = 0;
	// Configurar los baudios
	/**
	 * USARTDIV = 16E+6 / (16 * 115200)
	 * USARTDIV = 8.6805
	 * MANTISA = 0x8
	 * fraction = 0.6805 * 16 = 10.88 -> 11
	 * FRACTION = 0xB
	 * BRR = 0x8B;
	 */
	USART1->BRR = 0x8B;

	USART1->CR1 |= USART_CR1_TE | USART_CR1_RE;

	//habilitar
	USART1->CR1 |= USART_CR1_UE;
	return;
}

uint8_t uart_send_data(USART_TypeDef *USART, uint8_t *pData, uint32_t len, uint32_t timeout){
	uint32_t ticks = getTicks();
	while((getTicks() - ticks) < timeout){
		if(USART->SR & USART_SR_TXE){
			USART->DR = *pData;
			pData += 1;
			len -= 1;
			if(len == 0){
				return 0; 	//ok
			}
		}
	}
	return 1;  				//error
}
int32_t write_serial(const uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg){
	(void)arg;
	if(uart_send_data(USART1, (uint8_t*)buf, count, (uint32_t)byte_timeout_ms) == 0){
		return count;
	}
	return 0;
}
int32_t read_serial(uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg){
	(void)arg;
	uint32_t ticks = getTicks();
	uint32_t len = count;
	while((getTicks() - ticks) < (uint32_t)byte_timeout_ms){
		if(USART1->SR & USART_SR_RXNE){
			*buf = USART1->DR;
			len -= 1;
			if(len == 0){
				return count;
			}
		}
	}
	return 0;
}

void onError() {
	printf("error modbus");
  	// Make the LED blink on error
  	while (true) {
		GPIOG->ODR ^= 1<<13;
		delay_ms(100);
  	}
}