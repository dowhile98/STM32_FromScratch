/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "delay.h"
#include <stdio.h>
#include <string.h>
#include "main.h"
/*Defines --------------------------------------------------------------------*/

/*Typedefs -------------------------------------------------------------------*/

/*Global variables -----------------------------------------------------------*/
RxData_t data = {
		.len = 0
};
bool  rxFlag = false;

/*Function prototype ---------------------------------------------------------*/
void USART1_Config(void);
int __io_putchar(int ch){
	while(!(USART1->SR & USART_SR_TXE));
	//TDR
	//RDR
	USART1->DR = (uint8_t)(ch & 0xFF);
	return ch;
}

bool dataReady(void){
	bool flag = rxFlag;
	rxFlag = false;
	return flag;
}
uint8_t uart_send_data(USART_TypeDef *USART, uint8_t *pData, uint32_t len, uint32_t timeout);
/*Main function --------------------------------------------------------------*/
int main(void)
{
	USART1_Config();
	//habilitar la interrupcion para la recepcion
	USART1->CR1 |= USART_CR1_RXNEIE;
	NVIC_EnableIRQ(USART1_IRQn);
	NVIC_SetPriority(USART1_IRQn, 2);

	printf("USART1 Init OK!\r\n");
	/**
	 * PG12
	 */
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOGEN;
	GPIOG->MODER &=~ GPIO_MODER_MODE12;
	GPIOG->MODER |= GPIO_MODER_MODE12_0;
	/**
	 * GENERACION DE BASE DE TIEMPO
	 */
	RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
	TIM6->CR1 = 0;
	/*
	 * F = 16MHZ
	 * UPDATE  = 1KHZ
	 * PSC = 16 - 1
	 * ARR = F /(PSC + 1)(UPDATE) - 1
	 */
	TIM6->PSC = 16 - 1;
	TIM6->ARR = 1000 - 1;
	TIM6->DIER |= TIM_DIER_UIE;
	NVIC_EnableIRQ(TIM6_DAC_IRQn);
	NVIC_SetPriority(TIM6_DAC_IRQn, 0xF);

	TIM6->CR1 |= TIM_CR1_CEN;
	/**
	 * GENERACION DE SEÃ‘AL
	 */
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	TIM2->CR1 = 0;
	TIM2->PSC = 0;
	TIM2->ARR = 0xFFFFFFFF;
	//Configuracion canal
	//PA1 -> TIM2_CH1
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER &=~ GPIO_MODER_MODE1;
	GPIOA->MODER |= GPIO_MODER_MODE1_1;
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED1;
	GPIOA->AFR[0] &=~ GPIO_AFRL_AFSEL1;
	GPIOA->AFR[0] |= 0x1<<GPIO_AFRL_AFSEL1_Pos;

	//TIM2_CH1
	TIM2->CCMR1 &=~ TIM_CCMR1_CC2S;		//canal se configura como salida
	TIM2->CCMR1 &=~ TIM_CCMR1_OC2M;
	TIM2->CCMR1 |= 0x3<<TIM_CCMR1_OC2M_Pos; //toggle
	TIM2->CCER |= TIM_CCER_CC2E;			//habilita el canal
	TIM2->CCR2  = 160;
	TIM2->DIER |= TIM_DIER_CC2IE;
	NVIC_EnableIRQ(TIM2_IRQn);

    /* Loop forever */
	for(;;){

	}
}
/*Function definition --------------------------------------------------------*/
void USART1_Config(void){
	//1. configurar los pines
	//PA9 y PA10
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER &=~ (GPIO_MODER_MODE9 | GPIO_MODER_MODE10);
	GPIOA->MODER |= GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1; //FA

	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED9 | GPIO_OSPEEDR_OSPEED10;  //Very high speed
	//Asignacion de funcion alternativa
	GPIOA->AFR[1] &=~(GPIO_AFRH_AFSEL9 | GPIO_AFRH_AFSEL10);
	GPIOA->AFR[1] |= 0x7<<GPIO_AFRH_AFSEL9_Pos | 0x7<<GPIO_AFRH_AFSEL10_Pos;
	//2. habilitar el reloj
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
	//3. Deshabilitar
	USART1->CR1 = 0;
	// Configurar los baudios
	/**
	 * USARTDIV = 16E+6 / (16 * 115200)
	 * USARTDIV = 8.6805
	 * MANTISA = 0x8
	 * fraction = 0.6805 * 16 = 10.88 -> 11
	 * FRACTION = 0xB
	 * BRR = 0x8B;
	 */
	USART1->BRR = 0x8B;

	USART1->CR1 |= USART_CR1_TE | USART_CR1_RE;

	//habilitar
	USART1->CR1 |= USART_CR1_UE;
	return;
}

uint8_t uart_send_data(USART_TypeDef *USART, uint8_t *pData, uint32_t len, uint32_t timeout){
	uint32_t ticks = getTicks();
	while((getTicks() - ticks) < timeout){
		if(USART->SR & USART_SR_TXE){
			USART->DR = *pData;
			pData += 1;
			len -= 1;
			if(len == 0){
				return 0; 	//ok
			}
		}
	}
	return 1;  				//error
}
