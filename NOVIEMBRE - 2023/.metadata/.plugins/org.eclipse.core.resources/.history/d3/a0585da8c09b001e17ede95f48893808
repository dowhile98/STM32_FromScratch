/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/**
 * LED1 -> PD12
 * LED2 -> PD15
 *
 * SW -> PA0
 *
 * NUCLEO 64
 * LED  -> PA5
 * SW   -> PC13
 * COM -> USART2
 */

/*Includes --------------------------------------*/
#include <stdint.h>
#include "stm32f4xx.h"
#include <stdio.h>
#include "delay.h"


/*defines ---------------------------------------*/
/**
 * ##
 */
#define LED			D, 12
#define SW			A, 0

#define SPI1_SCK		A, 5
#define SPI1_MOSI		A, 7
#define SPI1_MISO		A, 6
#define SPI1_NSS		B, 6


#define GPIOX_MODER_(a, b, c)	{GPIO ## a ->MODER &=~ (0x3<<(2 * b)) ; \
								GPIO ## a ->MODER |= c <<( 2 * b); }
#define GPIOX_MODER(a, b)		GPIOX_MODER_(a, b)

#define INPUT_READ_(a, b)		(GPIO ## a -> IDR & 1<<b) ? 1 : 0
#define INPUT_READ(a)			INPUT_READ_(a)

#define OUTPUT_SET_(a, b)		GPIO ## a -> ODR |= 1<<b
#define OUTPUT_SET(a)			OUTPUT_SET_(a)

#define OUTPUT_RESET_(a, b)		GPIO ## a -> ODR &=~( 1<<b)
#define OUTPUT_RESET(a)			OUTPUT_RESET_(a)

/*Function prototype ----------------------------*/

/**
 * @brief SPI send data
 */
void SPI_SendData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer, uint32_t Len);
/**
 * @brief transmitirRecibir
 */
void SPI_SendReceiveData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer,uint8_t *pRxBuffer,uint32_t Len);
/**
 * @brief SPI receive data
 */
void SPI_ReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len);
/**
 * @brief master receive data
 */
void SPI_MasterReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len);

/*Main ------------------------------------------*/
int main(void)
{
	uint32_t temp;
	uint32_t ledTicks;
	/*habilitar el reloj*/
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;  //1<<3
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	/**
	 * PD12 -> salida
	 *
	 */
	GPIOD->MODER &=~(GPIO_MODER_MODE12); 	//Clear
	GPIOD->MODER |= GPIO_MODER_MODE12_0;	//Modo salida de proposito general
	GPIOD->OTYPER &=~ GPIO_OTYPER_OT12;		//PUSH PULL
	GPIOD->OSPEEDR &=~ GPIO_OSPEEDER_OSPEEDR12;
	/**
	 * PA0 -> entrada
	 */
	GPIOA->MODER &=~(GPIO_MODER_MODE0); //RESET STATE (INPUT FLOATING)
	GPIOA->PUPDR &=~ (GPIO_PUPDR_PUPD0); //no pull up /down

	/**
	 * @brief systick
	 * 
	 */
	temp = 16E+6 / 1E+3;
	SysTick_Config(temp);
	ledTicks = getTicks();
	/* SPI ----------------------------------------------------*/
	/**
	 * PA5 -> SPI1_CLK
	 * PA6 -> SPI1_MISO
	 * PA7 -> SPI1_MOSI
	 * PB6 -> SPI1_NSS
	 */
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN;
	GPIOX_MODER(SPI1_SCK, 0x2);
	GPIOX_MODER(SPI1_MOSI, 0x2);
	GPIOX_MODER(SPI1_MISO, 0x2);
	GPIOX_MODER(SPI1_NSS, 0x1);
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED5 | GPIO_OSPEEDR_OSPEED6 | GPIO_OSPEEDR_OSPEED7;

	GPIOA->AFR[0] = 0;
	GPIOA->AFR |= 5<<GPIO_AFRL_AFSEL5_Pos | 5<<GPIO_AFRL_AFSEL6_Pos | 5<<GPIO_AFRL_AFSEL7_Pos;

	//SPI
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

	//Configurar el baudrate
	SPI1->CR1 &=~ SPI_CR1_BR;			//Pclk / 2 -> 8MZ
	SPI1->CR1 |= SPI_CR1_BR_0;			//PCLK / 4 -> 4MZ
	//CONFIGURAR LA POLARIDAD Y LA FASE DEL RELOJ
	SPI1->CR1 &=~ (SPI_CR1_CPHA | SPI_CR1_CPOL); //SPI MODO 0
	//longitud de la trama
	SPI1->CR1 &=~ SPI_CR1_DFF;			//8bit de datos
	//configurar el bit LSBFIRTS
	SPI1->CR1 &=~ SPI_CR1_LSBFIRST;		//MSB
	//Configurar el manejo del pin NSS
	SPI1->CR1 |= SPI_CR1_SSM | SPI_CR1_SSI; //software managment
	//configurar el TI

	//habilitar el spi y habilitar el modo maestro
	SPI1->CR1 |= SPI_CR1_MSTR | SPI_CR1_SPE;

	for(;;){

	}
}


/*Function definition -----------------------------------------*/
int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}


/**
 * @brief SPI send data
 */
void SPI_SendData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer, uint32_t Len){
	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & 1U<<1));
		//2. Verificar el bit DFF
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			SPIx->DR = *((uint16_t*)pTxBuffer);
			Len -= 2;
			(uint16_t*)pTxBuffer++;
		}else{
			//8bit
			*((__IO uint8_t*)&SPIx->DR) = *pTxBuffer;
			pTxBuffer++;
			Len--;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);
	return;
}

/**
 * @brief transmitirRecibir
 */
void SPI_SendReceiveData(SPI_TypeDef *SPIx,uint8_t *pTxBuffer,uint8_t *pRxBuffer,uint32_t Len){
	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			SPIx->DR = *((uint16_t*)pTxBuffer);

			//wait for RXNE
			while(!(SPIx->SR & SPI_SR_RXNE));
			*((uint16_t*)pRxBuffer) = SPIx->DR ;

			Len -= 2;
			(uint16_t*)pTxBuffer++;
			(uint16_t*)pRxBuffer++;
		}else{
			*((__IO uint8_t*)&SPIx->DR) = *pTxBuffer;

			//wait for RXNE
			while(!(SPIx->SR & SPI_SR_RXNE));
			*(pRxBuffer) = SPIx->DR;

			pTxBuffer++;
			pRxBuffer++;
			Len--;
		}
	}


	return;
}

/**
 * @brief SPI receive data
 */
void SPI_ReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len){
	while(Len>0){
		//wait until RXNE is set
		while(!(SPIx->SR & SPI_SR_RXNE));

		//2. check the DFF bit in CR1
		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit DFF
			//1. load the data from DR to Rxbuffer address
			*((uint16_t*)pRxBuffer) = SPIx->DR;
			Len -= 2;
			(uint16_t*)pRxBuffer++;
		}else{
			//8 bit DFF
			*(pRxBuffer) = SPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);

	return;
}


/**
 * @brief master receive data
 */
void SPI_MasterReceiveData(SPI_TypeDef *SPIx,uint8_t *pRxBuffer,uint32_t Len){

	while(Len>0){
		//1. esperar hasta que TXE se ponga a 1
		while(!(SPIx->SR & SPI_SR_TXE));

		if(SPIx->CR1 & SPI_CR1_DFF){
			//16 bit data
			//the clock is controlled by master
			//thus, the master must send a byte
			SPIx->DR = (uint16_t) 0xFFFF;			//write dummy
			//data to the slave to start the clock
			while(!(SPIx->SR & SPI_SR_RXNE));
			*((uint16_t*)pRxBuffer) = SPIx->DR;

			Len -= 2;
			(uint16_t*)pRxBuffer++;
		}else{
			//16 bit data
			//the clock is controlled by master
			//thus, the master must send a byte
			*((__IO uint8_t*)&SPIx->DR) = 0xFF;		//dummy byte
			//data to the slave to start the clock
			while(!(SPIx->SR & SPI_SR_RXNE));
			*(pRxBuffer) = SPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
	//esperar hasta que el SPI se libere
	while(SPIx->SR & SPI_SR_BSY);
	return;
}
