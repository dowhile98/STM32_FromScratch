/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "delay.h"
#include <stdio.h>
#include <string.h>
#include "main.h"
/*Defines --------------------------------------------------------------------*/

/*Typedefs -------------------------------------------------------------------*/

/*Global variables -----------------------------------------------------------*/
RxData_t data = {
		.len = 0
};
bool  rxFlag = false;

/*Function prototype ---------------------------------------------------------*/
void USART1_Config(void);
int __io_putchar(int ch){
	while(!(USART1->SR & USART_SR_TXE));
	//TDR
	//RDR
	USART1->DR = (uint8_t)(ch & 0xFF);
	return ch;
}

bool dataReady(void){
	return rxFlag;
}
uint8_t uart_send_data(USART_TypeDef *USART, uint8_t *pData, uint32_t len, uint32_t timeout);
/*Main function --------------------------------------------------------------*/
int main(void)
{
	uint8_t txt[50];
	SysTick_Config(16000);
	USART1_Config();
	//habilitar la interrupcion para la recepcion
	USART1->CR1 |= USART_CR1_RXNEIE;
	NVIC_EnableIRQ(USART1_IRQn);
	NVIC_SetPriority(USART1_IRQn, 2);

	printf("USART1 Init OK!\r\n");
    /* Loop forever */
	for(;;){
//		printf("hola mundo\r\n");
//		sprintf((char*)txt, "val: %.2f\r\n", 3.14);
//		uart_send_data(USART1, txt, strlen((char*)txt), 100);
//		delay_ms(500);
		if(dataReady()){
			printf("data: %s", data.rx);
			printf("data len: %d\r\n", data.len);
		}
	}
}
/*Function definition --------------------------------------------------------*/
void USART1_Config(void){
	//1. configurar los pines
	//PA9 y PA10
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER &=~ (GPIO_MODER_MODE9 | GPIO_MODER_MODE10);
	GPIOA->MODER |= GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1; //FA

	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED9 | GPIO_OSPEEDR_OSPEED10;  //Very high speed
	//Asignacion de funcion alternativa
	GPIOA->AFR[1] &=~(GPIO_AFRH_AFSEL9 | GPIO_AFRH_AFSEL10);
	GPIOA->AFR[1] |= 0x7<<GPIO_AFRH_AFSEL9_Pos | 0x7<<GPIO_AFRH_AFSEL10_Pos;
	//2. habilitar el reloj
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
	//3. Deshabilitar
	USART1->CR1 = 0;
	// Configurar los baudios
	/**
	 * USARTDIV = 16E+6 / (16 * 115200)
	 * USARTDIV = 8.6805
	 * MANTISA = 0x8
	 * fraction = 0.6805 * 16 = 10.88 -> 11
	 * FRACTION = 0xB
	 * BRR = 0x8B;
	 */
	USART1->BRR = 0x8B;

	USART1->CR1 |= USART_CR1_TE | USART_CR1_RE;

	//habilitar
	USART1->CR1 |= USART_CR1_UE;
	return;
}

uint8_t uart_send_data(USART_TypeDef *USART, uint8_t *pData, uint32_t len, uint32_t timeout){
	uint32_t ticks = getTicks();
	while((getTicks() - ticks) < timeout){
		if(USART->SR & USART_SR_TXE){
			USART->DR = *pData;
			pData += 1;
			len -= 1;
			if(len == 0){
				return 0; 	//ok
			}
		}
	}
	return 1;  				//error
}
