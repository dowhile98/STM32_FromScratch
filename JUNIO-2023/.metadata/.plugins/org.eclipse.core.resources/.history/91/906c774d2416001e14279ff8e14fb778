/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ----------------------------------------------------*/
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "stm32f4xx.h"
#include "core_cm4.h"
#include "SysTick.h"
#include "HD44780.h"
#include "GPIO.h"
#include "UART.h"
#include "lwrb.h"
/*Typedef -----------------------------------------------------*/

/*Defines -----------------------------------------------------*/

/*Global variables --------------------------------------------*/
lwrb_t rxBuff;
uint8_t rx_data[64];
/*Function prototype ------------------------------------------*/
int __io_putchar(int ch){
	uint8_t c = ch & 0xFF;
	//salida
	//ITM_SendChar(ch);
	while(!(USART2->SR & USART_SR_TXE));
	USART2->DR = c;
	return ch;
}

int32_t read_serial(uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg){
	uint32_t tickStart = GetTicks();
	while((GetTicks() - tickStart)<= byte_timeout_ms){
		if(lwrb_get_full(&rxBuff)>= count){
			lwrb_read(&rxBuff, buff, count);
		}
	}
}
int32_t write_serial(const uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg) {
	(void)arg;
	return UART_SendData(USART2, buf, coun, byte_timeout_ms);
}
/*main function -----------------------------------------------*/
int main(void)
{
	uint32_t ticks;
	GPIO_ConfigTypedef_t uartPin;
	UART_ConfigTypedef_t uart2 = {0};
	uint8_t txt[100] = {0};
	uint8_t rx[10] = {0};


	//PD12->salida
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
	GPIOD->MODER &=~ GPIO_MODER_MODE12;
	GPIOD->MODER |= GPIO_MODER_MODE12_0;
	/**
	 * ticks = 16MHz * 0.001
	 * ticks = 16000
	 */
	ticks = 16000;
	SysTick_Init(ticks);

	ticks = GetTicks();

	/*Lcd init -----------------------------------*/
	/**
	 * PA2 ->TX
	 * PA3 ->RX
	 */
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	uartPin.pin = GPIO_PIN_2 | GPIO_PIN_3;
	uartPin.mode = GPIO_MODE_AF;
	uartPin.pullup = GPIO_PU_NONE;
	uartPin.speed = GPIO_SPEED_HIGH;
	uartPin.outputType = GPIO_OT_PP;
	uartPin.AF = 0x7U;
	BSP_PinInit(GPIOA, &uartPin);
	/**
	 * USARTDIV = 16E+6 / (16 * 115200)
	 * USARTDIV = 8.68055Â´
	 * USARTFRACTION = 0.6805 * 16 = 10.888888 -> 11->B
	 * 8 -> 0x8
	 * BRR = 0x8B
	 */
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

	uart2.baud = 115200;
	uart2.mode = UART_TE_EN | UART_RE_EN;
	uart2.stopBit = UART_STOP_1B;
	uart2.over = UART_OVER_16;
	uart2.parity = UART_PARITY_NONE;
	uart2.wordLength = UART_DATA_8B;
	uart2.pclk = 16E+6;

	UART_Init(USART2, &uart2);

	//HAL -> HIGH ABSTRACTION LAYER
	printf("hola mundo desde usart2\r\n");

	//tx
	sprintf((char*)txt, "esto es una prueba de la funcion tx\r\n");
	UART_SendData(USART2, txt, strlen((char*)txt), 100);
	//rx
	UART_ReceiveData(USART2, rx, 3, 5000);
	sprintf((char*)txt, "rx:%s\r\n", rx);
	UART_SendData(USART2, txt, strlen((char*)txt), 100);
	/**
	 * RING BUFFER
	 */
	lwrb_init(&rxBuff, rx_data, 64);
	/**
	 * INTERRUPCION USART RXNE
	 */
	USART2->CR1 |= USART_CR1_RXNEIE;
	NVIC_EnableIRQ(USART2_IRQn);
	NVIC_SetPriority(USART2_IRQn, 2);

	/**
	 *
	 */
	//
    /* Loop forever */
	for(;;){
		//leer adc

		//mostar en la pantalla contenido


		//lectora de botones



	}
}
/*Function definition -----------------------------------------*/


