/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ----------------------------------------------------*/
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "stm32f4xx.h"
#include "core_cm4.h"
#include "SysTick.h"
#include "HD44780.h"
#include "GPIO.h"
#include "UART.h"
#include "lwrb.h"
#include "nanomodbus.h"
/*Typedef -----------------------------------------------------*/

/*Defines -----------------------------------------------------*/
// The data model of this sever will support coils addresses 0 to 100 and registers addresses from 0 to 32
#define COILS_ADDR_MAX 100
#define REGS_ADDR_MAX 32

// Our RTU address
#define RTU_SERVER_ADDRESS 1
/*Global variables --------------------------------------------*/
lwrb_t rxBuff;
uint8_t rx_data[64];
nmbs_bitfield server_coils = {0};
uint16_t server_registers[REGS_ADDR_MAX] = {0};
/*Function prototype ------------------------------------------*/
int __io_putchar(int ch){
	uint8_t c = ch & 0xFF;
	//salida
	//ITM_SendChar(ch);
	while(!(USART2->SR & USART_SR_TXE));
	USART2->DR = c;
	return ch;
}

int32_t read_serial(uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg){
	uint32_t tickStart = GetTicks();
	while((GetTicks() - tickStart)<= byte_timeout_ms){
		if(lwrb_get_full(&rxBuff)>= count){
			return lwrb_read(&rxBuff, buff, count);
		}
	}
	return 0;
}
int32_t write_serial(const uint8_t* buf, uint16_t count, int32_t byte_timeout_ms, void* arg) {
	(void)arg;
	return UART_SendData(USART2, buf, coun, byte_timeout_ms);
}

nmbs_error handle_read_coils(uint16_t address, uint16_t quantity, nmbs_bitfield coils_out, void *arg) {
  if (address + quantity > COILS_ADDR_MAX + 1)
    return NMBS_EXCEPTION_ILLEGAL_DATA_ADDRESS;

  // Read our coils values into coils_out
  for (int i = 0; i < quantity; i++) {
    bool value = nmbs_bitfield_read(server_coils, address + i);
    nmbs_bitfield_write(coils_out, i, value);
  }

  return NMBS_ERROR_NONE;
}


nmbs_error handle_write_multiple_coils(uint16_t address, uint16_t quantity, const nmbs_bitfield coils, void *arg) {
  if (address + quantity > COILS_ADDR_MAX + 1)
    return NMBS_EXCEPTION_ILLEGAL_DATA_ADDRESS;

  // Write coils values to our server_coils
  for (int i = 0; i < quantity; i++) {
    nmbs_bitfield_write(server_coils, address + i, nmbs_bitfield_read(coils, i));
  }

  return NMBS_ERROR_NONE;
}


nmbs_error handler_read_holding_registers(uint16_t address, uint16_t quantity, uint16_t* registers_out, void *arg) {
  if (address + quantity > REGS_ADDR_MAX + 1)
    return NMBS_EXCEPTION_ILLEGAL_DATA_ADDRESS;

  // Read our registers values into registers_out
  for (int i = 0; i < quantity; i++)
    registers_out[i] = server_registers[address + i];

  return NMBS_ERROR_NONE;
}


nmbs_error handle_write_multiple_registers(uint16_t address, uint16_t quantity, const uint16_t* registers, void *arg) {
  if (address + quantity > REGS_ADDR_MAX + 1)
    return NMBS_EXCEPTION_ILLEGAL_DATA_ADDRESS;

  // Write registers values to our server_registers
  for (int i = 0; i < quantity; i++)
    server_registers[address + i] = registers[i];

  return NMBS_ERROR_NONE;
}
/*main function -----------------------------------------------*/
int main(void)
{
	uint32_t ticks;
	GPIO_ConfigTypedef_t uartPin;
	UART_ConfigTypedef_t uart2 = {0};
	uint8_t txt[100] = {0};
	uint8_t rx[10] = {0};


	//PD12->salida
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
	GPIOD->MODER &=~ GPIO_MODER_MODE12;
	GPIOD->MODER |= GPIO_MODER_MODE12_0;
	/**
	 * ticks = 16MHz * 0.001
	 * ticks = 16000
	 */
	ticks = 16000;
	SysTick_Init(ticks);

	ticks = GetTicks();

	/*Lcd init -----------------------------------*/
	/**
	 * PA2 ->TX
	 * PA3 ->RX
	 */
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	uartPin.pin = GPIO_PIN_2 | GPIO_PIN_3;
	uartPin.mode = GPIO_MODE_AF;
	uartPin.pullup = GPIO_PU_NONE;
	uartPin.speed = GPIO_SPEED_HIGH;
	uartPin.outputType = GPIO_OT_PP;
	uartPin.AF = 0x7U;
	BSP_PinInit(GPIOA, &uartPin);
	/**
	 * USARTDIV = 16E+6 / (16 * 115200)
	 * USARTDIV = 8.68055Â´
	 * USARTFRACTION = 0.6805 * 16 = 10.888888 -> 11->B
	 * 8 -> 0x8
	 * BRR = 0x8B
	 */
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

	uart2.baud = 115200;
	uart2.mode = UART_TE_EN | UART_RE_EN;
	uart2.stopBit = UART_STOP_1B;
	uart2.over = UART_OVER_16;
	uart2.parity = UART_PARITY_NONE;
	uart2.wordLength = UART_DATA_8B;
	uart2.pclk = 16E+6;

	UART_Init(USART2, &uart2);

	//HAL -> HIGH ABSTRACTION LAYER
	printf("hola mundo desde usart2\r\n");

	//tx
	sprintf((char*)txt, "esto es una prueba de la funcion tx\r\n");
	UART_SendData(USART2, txt, strlen((char*)txt), 100);
	//rx
	UART_ReceiveData(USART2, rx, 3, 5000);
	sprintf((char*)txt, "rx:%s\r\n", rx);
	UART_SendData(USART2, txt, strlen((char*)txt), 100);
	/**
	 * RING BUFFER
	 */
	lwrb_init(&rxBuff, rx_data, 64);
	/**
	 * INTERRUPCION USART RXNE
	 */
	USART2->CR1 |= USART_CR1_RXNEIE;
	NVIC_EnableIRQ(USART2_IRQn);
	NVIC_SetPriority(USART2_IRQn, 2);

	/**
	 * MOBDBUS
	 */
	nmbs_platform_conf platform_conf = {0};
	platform_conf.transport = NMBS_TRANSPORT_RTU;
	platform_conf.read = read_serial;
	platform_conf.write = write_serial;
	platform_conf.arg = NULL;

	nmbs_callbacks callbacks = {0};
	callbacks.read_coils = handle_read_coils;
	callbacks.write_multiple_coils = handle_write_multiple_coils;
	callbacks.read_holding_registers = handler_read_holding_registers;
	callbacks.write_multiple_registers = handle_write_multiple_registers;

	// Create the modbus server
	nmbs_t nmbs;
	nmbs_error err = nmbs_server_create(&nmbs, RTU_SERVER_ADDRESS, &platform_conf, &callbacks);
	if (err != NMBS_ERROR_NONE) {
	   while(1){

	   }
	}
	nmbs_set_read_timeout(&nmbs, 1000);
	nmbs_set_byte_timeout(&nmbs, 100);
	//
    /* Loop forever */
	for(;;){
		//leer adc
		err = nmbs_server_poll(&nmbs);
		//mostar en la pantalla contenido
		delay_ms(100);

		//lectora de botones



	}
}
/*Function definition -----------------------------------------*/


