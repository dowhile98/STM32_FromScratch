/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ------------------------------------------------------------*/
#include <stdint.h>
#include "stm32l4xx.h"
#include "defines.h"
#include "SystemTime.h"
/*Tyepdef -------------------------------------------------------------*/

/*Defines -------------------------------------------------------------*/
#define LED			B, 3
#define ADC_IN5		A, 0
#define ADC_IN6		A, 1
#define ADC_IN7		A, 2

/*Global variable -----------------------------------------------------*/
uint16_t data[3];
/*Function prototype --------------------------------------------------*/
void adc1_read_ch567(uint16_t *pdata){
	ADC1->CR |= ADC_CR_ADSTART;
	while(!(ADC_ISR_EOC));
	pdata[0] = ADC1->DR;
	while(!(ADC_ISR_EOC));
	pdata[1] = ADC1->DR;
	while(!(ADC_ISR_EOC));
	pdata[2] = ADC1->DR;
	return;
}
/*Main function -------------------------------------------------------*/
int main(void)
{
	System_Tick_Init(4000);
	//ADC PIN INIT
	RCC->AHB2ENR |= GPIOX_CLOCK(ADC_IN5);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC_IN5);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC_IN6);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC_IN7);
	GPIOX_PUPDR(MODE_PU_NONE, ADC_IN5);
	GPIOX_PUPDR(MODE_PU_NONE, ADC_IN6);
	GPIOX_PUPDR(MODE_PU_NONE, ADC_IN7);

	//ADC INIT
	RCC->AHB2ENR |= RCC_AHB2ENR_ADCEN;
	ADC12_COMMON->CCR &=~ ADC_CCR_CKMODE;
	ADC12_COMMON->CCR &=~ ADC_CCR_PRESC;
	ADC12_COMMON->CCR &=~ ADC_CCR_DUAL;

	/*exit Deep-power-down mode*/
	ADC1->CR &=~ ADC_CR_DEEPPWD;
	ADC1->CR |= ADC_CR_ADVREGEN;
	//->calibrabtion
	delay_ms(1);
	ADC1->CR &=~ ADC_CR_ADEN;
	ADC1->CR &=~ ADC_CR_ADCALDIF; 		//Single eneded calibration
	ADC1->CR |= ADC_CR_ADCAL;
	while(ADC1->CR & ADC_CR_ADCAL);

	ADC1->CFGR = 0;						//Defacut parameters

	//->SAMPLING TIME CONFIGURATION
	ADC1->SMPR1 |= ADC_SMPR1_SMP5_1;    //IN5 -> 12.5 ADC clock cycles
	ADC1->SMPR1 |= ADC_SMPR1_SMP6_1;    //IN6 -> 12.5 ADC clock cycles
	ADC1->SMPR1 |= ADC_SMPR1_SMP7_1;    //IN7 -> 12.5 ADC clock cycles

	//->Secuence of convertions and number of convertion
	ADC1->SQR1 = (3 - 1)<<ADC_SQR1_L_Pos;
	ADC1->SQR1 |= 5U<<ADC_SQR1_SQ1_Pos | 6U<<ADC_SQR1_SQ2_Pos | 7U<<ADC_SQR1_SQ3_Pos;
	//habilitar las interrupciones (solo se recomiendo para leer un canal)
//	ADC1->IER |= ADC_IER_EOC;
//	ADC1->IER |= ADC_IER_EOS;
//	NVIC_EnableIRQ(ADC1_IRQn);
	//para el caso de mas de un canal utilizar DMA
	//->ENABLE ADC
	ADC1->ISR |= ADC_ISR_ADRDY;
	ADC1->CR |= ADC_CR_ADEN;
	while(!(ADC1->ISR & ADC_ISR_ADRDY));

    /* Loop forever */
	for(;;){
		adc1_read_ch567(data);
		delay_ms(100);
	}
}

/*Function definition -------------------------------------------------*/
